<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Wizardry Nodes (Read-only)</title>
  <style>
    :root{color-scheme:dark}
    html,body{height:100%;margin:0;background:#0b0b0e;color:#eee;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    #wrap{display:flex;height:100vh;overflow:hidden}
    #viewer{flex:1;position:relative;min-width:0;touch-action:none;} /* 중요: 모바일 제스처는 svg-pan-zoom이 처리 */
    #side{
      width:320px; max-width:48vw;
      border-left:1px solid #242433;
      background:#0f0f14;
      padding:12px; box-sizing:border-box;
      overflow:auto;
    }
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:8px 0}
    .btn{
      padding:8px 10px;border-radius:10px;border:1px solid #2e2e45;
      background:#191925;color:#eee;cursor:pointer;
      font-weight:600;font-size:13px;
    }
    .btn:active{transform:translateY(1px)}
    .muted{opacity:.75;font-size:12px;line-height:1.35}
    hr{border:0;border-top:1px solid #242433;margin:12px 0}
    label{display:flex;align-items:center;gap:8px;margin:8px 0}
    input[type="checkbox"]{transform:scale(1.15)}
    /* 모바일에서는 패널을 아래로 */
    @media (max-width: 820px){
      #wrap{flex-direction:column}
      #side{width:100%;max-width:none;max-height:42vh;border-left:none;border-top:1px solid #242433}
      #viewer{height:58vh}
    }

    /* SVG 핀 */
    .pin{cursor:pointer}
    .r{fill:#d63a3a}.b{fill:#2f6bff}.g{fill:#20a56b}
    .num{fill:#fff;font-weight:900;font-size:14px;pointer-events:none}
    .pin circle{stroke:rgba(255,255,255,.85);stroke-width:2}
    /* 툴팁 */
    .tip-box{fill:rgba(15,15,20,.92);stroke:rgba(255,255,255,.25);stroke-width:1}
    .tip-title{fill:#fff;font-weight:900;font-size:14px}
    .tip-text{fill:rgba(255,255,255,.9);font-size:12px}
  </style>
</head>

<body>
<div id="wrap">
  <div id="viewer">
    <svg id="svg" width="100%" height="100%" viewBox="0 0 2996 2832" xmlns="http://www.w3.org/2000/svg">
      <image id="bg" href="tree.png" x="0" y="0" width="2996" height="2832" />
      <!-- 노드 -->
      <g id="pins"></g>

      <!-- SVG 내부 툴팁(좌표계가 같아서 PC/모바일 모두 "노드 자리"에 정확히 뜸) -->
      <g id="tooltip" visibility="hidden">
        <rect id="tipRect" class="tip-box" x="0" y="0" rx="10" ry="10" width="260" height="60"></rect>
        <text id="tipTitle" class="tip-title" x="12" y="10" dominant-baseline="hanging"></text>
        <text id="tipText" class="tip-text" x="12" y="30" dominant-baseline="hanging"></text>
      </g>
    </svg>
  </div>

  <aside id="side">
    <div class="row"><b id="count">노드: ...</b></div>

    <div class="row">
      <button class="btn" id="btnFit">화면에 맞춤</button>
      <button class="btn" id="btnCloseTip">말풍선 닫기</button>
    </div>

    <hr/>

    <div><b>필터</b></div>
    <label><input type="checkbox" id="f-r" checked>빨강</label>
    <label><input type="checkbox" id="f-b" checked>파랑</label>
    <label><input type="checkbox" id="f-g" checked>초록</label>

    <hr/>
    <div class="muted">
      • 노드 탭/클릭하면 제목/설명이 말풍선으로 떠.<br/>
      • PC: 마우스 휠로 확대/축소, 드래그로 이동 가능.<br/>
      • 모바일: 두 손가락으로 확대/이동 가능.<br/>
      • 이미지/노드가 안 맞아 보이면 “화면에 맞춤” 눌러.
    </div>
  </aside>
</div>

<script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>

<script>
  // === 이미지 크기(사용자 제공): 2996 x 2832 ===
  const IMG_W = 2996, IMG_H = 2832;

  // --- svg-pan-zoom 모바일 터치 핸들러(Hammer.js) ---
  const eventsHandler = {
    haltEventListeners: ['touchstart','touchend','touchmove','touchleave','touchcancel'],
    init: function(options) {
      const instance = options.instance;
      let initialScale = 1;
      let pannedX = 0, pannedY = 0;

      this.hammer = new Hammer(options.svgElement, { inputClass: Hammer.TouchInput });
      this.hammer.get('pinch').set({ enable: true });

      // 더블탭 확대 비활성(요구사항)
      this.hammer.get('doubletap') && this.hammer.get('doubletap').set({ enable: false });

      this.hammer.on('panstart panmove', function(ev) {
        if (ev.type === 'panstart') { pannedX = 0; pannedY = 0; }
        instance.panBy({ x: ev.deltaX - pannedX, y: ev.deltaY - pannedY });
        pannedX = ev.deltaX; pannedY = ev.deltaY;
      });

      this.hammer.on('pinchstart pinchmove', function(ev) {
        if (ev.type === 'pinchstart') initialScale = instance.getZoom();
        instance.zoomAtPoint(initialScale * ev.scale, { x: ev.center.x, y: ev.center.y });
      });

      // 페이지 스크롤 방지(캔버스 영역에서)
      options.svgElement.addEventListener('touchmove', function(e){ e.preventDefault(); }, { passive:false });
    },
    destroy: function(){ this.hammer && this.hammer.destroy(); }
  };

  const panZoom = svgPanZoom('#svg', {
    zoomEnabled: true,
    panEnabled: true,
    controlIconsEnabled: false,
    fit: true,
    center: true,
    minZoom: 0.15,
    maxZoom: 20,
    dblClickZoomEnabled: false,           // 더블클릭 확대 OFF
    preventMouseEventsDefault: false,     // 클릭 이벤트가 먹게
    customEventsHandler: eventsHandler
  });

  // 로딩 타이밍(모바일에서 초기 fit이 꼬이는 것 방지)
  function forceFitCenter() {
    try { panZoom.resize(); panZoom.fit(); panZoom.center(); } catch(e) {}
  }
  window.addEventListener('load', () => { forceFitCenter(); setTimeout(forceFitCenter, 150); setTimeout(forceFitCenter, 450); });
  window.addEventListener('resize', () => { forceFitCenter(); });

  // --- nodes.json 로드 ---
  async function loadNodes() {
    const res = await fetch('nodes.json', { cache: 'no-store' });
    const data = await res.json();
    if (Array.isArray(data)) return data;
    if (data && Array.isArray(data.nodes)) return data.nodes;
    return [];
  }

  const pinsEl = document.getElementById('pins');
  const tip = document.getElementById('tooltip');
  const tipRect = document.getElementById('tipRect');
  const tipTitle = document.getElementById('tipTitle');
  const tipText = document.getElementById('tipText');

  function setTipVisible(v){ tip.setAttribute('visibility', v ? 'visible' : 'hidden'); }

  // 텍스트를 여러 줄(tspan)로 렌더
  function setMultilineText(textEl, lines) {
    while (textEl.firstChild) textEl.removeChild(textEl.firstChild);
    lines.forEach((ln, i) => {
      const tspan = document.createElementNS('http://www.w3.org/2000/svg','tspan');
      tspan.setAttribute('x', textEl.getAttribute('x'));
      tspan.setAttribute('dy', i === 0 ? '0' : '1.2em');
      tspan.textContent = ln;
      textEl.appendChild(tspan);
    });
  }

  // 너무 긴 문장은 대충 줄바꿈(한글/영문 섞임 대응용 간단 래핑)
  function wrapText(str, maxLen) {
    if (!str) return [''];
    const rawLines = String(str).split('\n');
    const out = [];
    for (const l of rawLines) {
      let s = l.trim();
      if (!s) { out.push(''); continue; }
      while (s.length > maxLen) {
        out.push(s.slice(0, maxLen));
        s = s.slice(maxLen);
      }
      out.push(s);
    }
    return out;
  }

  function showTooltipAt(node) {
    const title = node.name || node.title || '(제목 없음)';
    const desc = node.desc || node.detail || node.description || '';

    tipTitle.textContent = '';
    tipText.textContent = '';

    tipTitle.textContent = title;

    const lines = wrapText(desc, 26).slice(0, 6); // 너무 길면 6줄까지만
    setMultilineText(tipText, lines);

    // tooltip 박스 크기 계산(대략)
    const lineCount = Math.max(1, lines.length);
    const w = 280;
    const h = 34 + (lineCount * 16);

    // 노드 근처에 배치 + 화면 밖으로 나가면 클램프
    let x = node.x + 22;
    let y = node.y - 12;
    if (x + w > IMG_W) x = node.x - w - 22;
    if (x < 0) x = 10;
    if (y + h > IMG_H) y = IMG_H - h - 10;
    if (y < 0) y = 10;

    tipRect.setAttribute('x', x);
    tipRect.setAttribute('y', y);
    tipRect.setAttribute('width', w);
    tipRect.setAttribute('height', h);

    tipTitle.setAttribute('x', x + 12);
    tipTitle.setAttribute('y', y + 10);

    tipText.setAttribute('x', x + 12);
    tipText.setAttribute('y', y + 30);

    setTipVisible(true);
  }

  function hideTooltip(){ setTipVisible(false); }

  function makeNodeEl(node){
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.classList.add('pin');
    g.dataset.c = node.c || node.color || 'r';

    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
    circle.setAttribute('cx', node.x);
    circle.setAttribute('cy', node.y);
    circle.setAttribute('r', node.radius || 14);
    circle.classList.add(g.dataset.c);

    const text = document.createElementNS('http://www.w3.org/2000/svg','text');
    text.setAttribute('x', node.x);
    text.setAttribute('y', node.y + 5);
    text.setAttribute('text-anchor','middle');
    text.classList.add('num');
    text.textContent = (node.n ?? node.num ?? '') || '';

    g.appendChild(circle);
    if (text.textContent) g.appendChild(text);

    // 클릭/탭: 말풍선 표시
    g.addEventListener('click', (ev) => {
      ev.stopPropagation();
      showTooltipAt(node);
    }, { passive: true });

    // 모바일에서 click이 씹히는 기기 대비: touchend도 추가
    g.addEventListener('touchend', (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      showTooltipAt(node);
    }, { passive: false });

    return g;
  }

  function applyFilter(){
    const fr = document.getElementById('f-r').checked;
    const fb = document.getElementById('f-b').checked;
    const fg = document.getElementById('f-g').checked;
    [...pinsEl.children].forEach(g=>{
      const c = g.dataset.c;
      const show = (c === 'r') ? fr : (c === 'b') ? fb : fg;
      g.style.display = show ? '' : 'none';
    });
  }

  // 배경(빈 곳) 클릭하면 말풍선 닫기
  document.getElementById('svg').addEventListener('click', () => hideTooltip(), { passive:true });
  document.getElementById('svg').addEventListener('touchend', (e) => { /* 빈곳 탭 닫기 */ hideTooltip(); }, { passive:true });

  document.getElementById('btnFit').addEventListener('click', () => { hideTooltip(); forceFitCenter(); });
  document.getElementById('btnCloseTip').addEventListener('click', () => hideTooltip());

  ['f-r','f-b','f-g'].forEach(id => document.getElementById(id).addEventListener('change', applyFilter));

  (async function init(){
    let nodes = [];
    try{
      nodes = await loadNodes();
    }catch(e){
      console.error(e);
      nodes = [];
    }

    document.getElementById('count').textContent = `노드: ${nodes.length}`;

    // 렌더
    pinsEl.innerHTML = '';
    for (const n of nodes){
      if (typeof n.x !== 'number' || typeof n.y !== 'number') continue;
      pinsEl.appendChild(makeNodeEl(n));
    }
    applyFilter();
    forceFitCenter();
  })();
</script>
</body>
</html>
