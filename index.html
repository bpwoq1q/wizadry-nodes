<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Wizardry Nodes (Read-only)</title>
  <style>
    :root{
      --bg:#0f0f12;
      --panel:#111118;
      --line:#2a2a33;
      --text:#e9e9ef;
      --muted:#a7a7b7;
      --accent:#5b8cff;
      --radius:14px;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;}
    #wrap{height:100%;display:flex;flex-direction:column;}
    #viewer{position:relative;flex:1;min-height:0;overflow:hidden;background:#000;}
    #svg{width:100%;height:100%;display:block;touch-action:none;} /* let svg-pan-zoom handle */

    /* Floating button to open panel (mobile-friendly) */
    #openPanel{
      position:absolute;right:12px;top:12px;z-index:30;
      background:rgba(20,20,26,.85);
      border:1px solid rgba(255,255,255,.12);
      color:var(--text);
      padding:10px 12px;border-radius:999px;
      font-weight:700;font-size:13px;
      backdrop-filter: blur(8px);
    }
    #openPanel:active{transform:translateY(1px);}

    /* Bottom drawer panel */
    #panel{
      position:fixed;
      left:0; right:0; bottom:0;
      z-index:40;
      background:rgba(17,17,24,.92);
      border-top:1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(10px);
      border-top-left-radius: var(--radius);
      border-top-right-radius: var(--radius);
      box-shadow: 0 -10px 30px rgba(0,0,0,.35);
      max-height: 65vh;
      transform: translateY(calc(100% - 56px));
      transition: transform .22s ease;
      padding-bottom: env(safe-area-inset-bottom);
    }
    #panel.open{ transform: translateY(0); }
    #panelHeader{
      height:56px;display:flex;align-items:center;justify-content:space-between;
      padding:0 14px;box-sizing:border-box;
      user-select:none;
    }
    #grab{
      width:48px;height:5px;border-radius:999px;background:rgba(255,255,255,.25);
      margin:8px auto 0;
    }
    #panelTitle{font-weight:800;font-size:14px;}
    #closePanel{
      background:transparent;border:0;color:var(--text);
      font-size:22px;line-height:1; padding:6px 10px; border-radius:10px;
    }
    #closePanel:active{background:rgba(255,255,255,.08);}
    #panelBody{padding:8px 16px 16px;}
    .row{display:flex;align-items:center;gap:10px;margin:10px 0;}
    .muted{color:var(--muted);font-size:12px;line-height:1.4;}
    .pill{
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.18);
      font-size:12px;
    }

    /* Tooltip bubble */
    #tip{
      position:absolute;
      z-index:35;
      max-width:min(320px, calc(100vw - 24px));
      background:rgba(15,15,20,.94);
      border:1px solid rgba(255,255,255,.14);
      border-radius:14px;
      padding:10px 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.4);
      backdrop-filter: blur(10px);
      display:none;
    }
    #tip h4{margin:0 0 6px 0;font-size:14px;}
    #tip p{margin:0;font-size:12px;color:var(--muted);white-space:pre-wrap;}
    #tipClose{
      position:absolute;right:8px;top:6px;
      border:0;background:transparent;color:var(--muted);
      font-size:18px;line-height:1;padding:4px 6px;border-radius:10px;
    }
    #tipClose:active{background:rgba(255,255,255,.08);}

    /* SVG pins */
    .pin{cursor:pointer}
    .r{fill:#d63a3a} .b{fill:#2f6bff} .g{fill:#20a56b}
    .ring{stroke:rgba(255,255,255,.92);stroke-width:2}
    .num{fill:#fff;font-weight:800;font-size:14px;pointer-events:none}
    .hidden{display:none}
  </style>
</head>
<body>
<div id="wrap">
  <div id="viewer">
    <button id="openPanel" type="button">필터/정보</button>
    <div id="tip" role="dialog" aria-label="노드 정보">
      <button id="tipClose" type="button" aria-label="닫기">×</button>
      <h4 id="tipTitle"></h4>
      <p id="tipBody"></p>
    </div>

    <svg id="svg" viewBox="0 0 2996 2832" xmlns="http://www.w3.org/2000/svg">
      <image id="bg" href="tree.png" x="0" y="0" width="2996" height="2832" />
      <g id="pins"></g>
    </svg>
  </div>

  <div id="panel" aria-label="옵션 패널">
    <div id="grab"></div>
    <div id="panelHeader">
      <div id="panelTitle">노드: <span id="nodeCount">0</span></div>
      <button id="closePanel" type="button" aria-label="패널 닫기">⌄</button>
    </div>
    <div id="panelBody">
      <div class="row">
        <span class="pill">✅ 빨강 <input type="checkbox" id="f-r" checked></span>
        <span class="pill">✅ 파랑 <input type="checkbox" id="f-b" checked></span>
        <span class="pill">✅ 초록 <input type="checkbox" id="f-g" checked></span>
      </div>
      <div class="muted">
        • 노드 누르면 말풍선으로 제목/상세가 뜹니다.<br>
        • 화면 드래그: 이동 / 핀치: 확대·축소<br>
        • 말풍선이 거슬리면 X로 닫거나, 빈 곳을 눌러 닫으세요.
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>
<script>
(() => {
  const IMG_W = 2996, IMG_H = 2832;
  const svg = document.getElementById('svg');
  const pinsLayer = document.getElementById('pins');

  // Panel controls
  const panel = document.getElementById('panel');
  const openPanelBtn = document.getElementById('openPanel');
  const closePanelBtn = document.getElementById('closePanel');
  openPanelBtn.addEventListener('click', () => panel.classList.toggle('open'));
  closePanelBtn.addEventListener('click', () => panel.classList.toggle('open'));
  // tap grab area to toggle
  document.getElementById('panelHeader').addEventListener('click', (e) => {
    if (e.target === closePanelBtn) return;
    panel.classList.toggle('open');
  });

  // Tooltip
  const tip = document.getElementById('tip');
  const tipTitle = document.getElementById('tipTitle');
  const tipBody = document.getElementById('tipBody');
  const tipClose = document.getElementById('tipClose');
  function hideTip(){ tip.style.display='none'; }
  tipClose.addEventListener('click', hideTip);
  // click outside tooltip to close (but not when clicking panel)
  document.getElementById('viewer').addEventListener('pointerdown', (e) => {
    if (tip.style.display !== 'none') {
      const inside = tip.contains(e.target);
      const onPanelBtn = openPanelBtn.contains(e.target);
      if (!inside && !onPanelBtn) hideTip();
    }
  }, {capture:true});

  // Load nodes
  let NODES = [];
  async function loadNodes(){
    try{
      const res = await fetch('nodes.json', {cache: 'no-store'});
      if(!res.ok) throw new Error('nodes.json fetch failed: ' + res.status);
      const data = await res.json();
      if(Array.isArray(data)) NODES = data;
      else if(Array.isArray(data.nodes)) NODES = data.nodes;
      else NODES = [];
    }catch(err){
      console.error(err);
      NODES = [];
    }
    document.getElementById('nodeCount').textContent = String(NODES.length);
  }

  function filters(){
    return {
      r: document.getElementById('f-r').checked,
      b: document.getElementById('f-b').checked,
      g: document.getElementById('f-g').checked
    };
  }

  function makePin(node){
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.classList.add('pin');
    g.dataset.c = node.c || 'r';

    const r = node.radius ?? 18;
    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
    circle.setAttribute('cx', node.x);
    circle.setAttribute('cy', node.y);
    circle.setAttribute('r', r);
    circle.classList.add(node.c || 'r');
    circle.classList.add('ring');

    const text = document.createElementNS('http://www.w3.org/2000/svg','text');
    text.setAttribute('x', node.x);
    text.setAttribute('y', node.y + 5);
    text.setAttribute('text-anchor', 'middle');
    text.classList.add('num');
    text.textContent = (node.n ?? '');

    g.appendChild(circle);
    if ((node.n ?? '') !== '') g.appendChild(text);

    g.addEventListener('click', (ev) => {
      ev.stopPropagation();
      showTipForNode(node);
    });

    return g;
  }

  function applyFilterToElement(el, f){
    const c = el.dataset.c || 'r';
    const show = !!f[c];
    el.classList.toggle('hidden', !show);
  }

  function renderPins(){
    pinsLayer.innerHTML = '';
    const f = filters();
    for(const node of NODES){
      const el = makePin(node);
      applyFilterToElement(el, f);
      pinsLayer.appendChild(el);
    }
  }

  ['f-r','f-b','f-g'].forEach(id => {
    document.getElementById(id).addEventListener('change', () => {
      const f = filters();
      [...pinsLayer.children].forEach(el => applyFilterToElement(el, f));
    });
  });

  // svg-pan-zoom init
  const panZoom = svgPanZoom('#svg', {
    zoomEnabled: true,
    panEnabled: true,
    controlIconsEnabled: false,
    fit: true,
    center: true,
    minZoom: 0.2,
    maxZoom: 20,
    dblClickZoomEnabled: false,
    preventMouseEventsDefault: true
  });

  // IMPORTANT: on mobile, initial fit/center sometimes doesn't apply until layout is stable
  function hardFit(){
    try{
      panZoom.resize();
      panZoom.fit();
      panZoom.center();
    }catch(e){}
  }
  window.addEventListener('resize', () => {
    hardFit();
    hideTip();
  });

  // Convert SVG point -> screen point for tooltip placement
  function svgToScreenPoint(x, y){
    const pt = svg.createSVGPoint();
    pt.x = x; pt.y = y;
    // Use current transformation matrix of SVG element
    const ctm = svg.getScreenCTM();
    if (!ctm) return {x: 12, y: 12};
    const sp = pt.matrixTransform(ctm);
    return {x: sp.x, y: sp.y};
  }

  function showTipAtScreen(x, y, title, body){
    tipTitle.textContent = title || '';
    tipBody.textContent = body || '';
    tip.style.display = 'block';

    // position with clamp
    const pad = 12;
    const vw = window.innerWidth, vh = window.innerHeight;
    // measure after display
    const rect = tip.getBoundingClientRect();
    let left = x + 10;
    let top  = y - rect.height - 10;

    // if above goes off, place below
    if (top < pad) top = y + 10;

    // clamp horizontally
    if (left + rect.width > vw - pad) left = vw - pad - rect.width;
    if (left < pad) left = pad;

    // clamp vertically (avoid panel peek area)
    const panelPeek = 64; // top portion of panel visible even when closed
    const maxTop = vh - panelPeek - rect.height - pad;
    if (top > maxTop) top = maxTop;

    tip.style.left = left + 'px';
    tip.style.top = top + 'px';
  }

  function showTipForNode(node){
    const title = node.name || node.title || '';
    const body  = node.desc || node.detail || node.description || '';
    const sp = svgToScreenPoint(node.x, node.y);
    showTipAtScreen(sp.x, sp.y, title, body);
  }

  // Close tooltip when panning/zooming
  svg.addEventListener('wheel', hideTip, {passive:true});
  svg.addEventListener('touchstart', hideTip, {passive:true});
  svg.addEventListener('pointerdown', (e) => {
    // if user starts panning on empty background, close tooltip
    if (e.target && e.target.id === 'bg') hideTip();
  });

  // Boot
  async function boot(){
    await loadNodes();
    renderPins();
    // Wait a tick for image/layout
    setTimeout(hardFit, 50);
    setTimeout(hardFit, 250);
  }
  window.addEventListener('load', boot);
})();
</script>
</body>
</html>
