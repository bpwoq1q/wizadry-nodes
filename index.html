<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Wizardry Nodes (Read-only)</title>
  <style>
    :root{color-scheme:dark}
    html,body{height:100%;margin:0;background:#0b0b0e;color:#eee;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    #wrap{display:flex;height:100vh;overflow:hidden}
    #viewer{flex:1;position:relative;min-width:0;touch-action:none;}
    #side{
      width:320px; max-width:48vw;
      border-left:1px solid #242433;
      background:#0f0f14;
      padding:12px; box-sizing:border-box;
      overflow:auto;
    }
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:8px 0}
    .btn{
      padding:8px 10px;border-radius:10px;border:1px solid #2e2e45;
      background:#191925;color:#eee;cursor:pointer;
      font-weight:600;font-size:13px;
    }
    .btn:active{transform:translateY(1px)}
    .muted{opacity:.75;font-size:12px;line-height:1.35}
    hr{border:0;border-top:1px solid #242433;margin:12px 0}
    label{display:flex;align-items:center;gap:8px;margin:8px 0}
    input[type="checkbox"]{transform:scale(1.15)}
    @media (max-width: 820px){
      #wrap{flex-direction:column}
      #side{width:100%;max-width:none;max-height:42vh;border-left:none;border-top:1px solid #242433}
      #viewer{height:58vh}
    }

    /* SVG 핀 */
    .pin{cursor:pointer}
    .r{fill:#d63a3a}.b{fill:#2f6bff}.g{fill:#20a56b}
    .num{fill:#fff;font-weight:900;font-size:15px;pointer-events:none}
    .pin circle{stroke:rgba(255,255,255,.85);stroke-width:2.4}

    /* 툴팁(크기/글자 크게) */
    .tip-box{fill:rgba(15,15,20,.92);stroke:rgba(255,255,255,.25);stroke-width:1}
    .tip-title{fill:#fff;font-weight:900;font-size:18px}
    .tip-text{fill:rgba(255,255,255,.92);font-size:15px}
  </style>
</head>

<body>
<div id="wrap">
  <div id="viewer">
    <svg id="svg" width="100%" height="100%" viewBox="0 0 2996 2832" xmlns="http://www.w3.org/2000/svg">
      <image id="bg" href="tree.png" x="0" y="0" width="2996" height="2832" />
      <g id="pins"></g>

      <defs>
        <clipPath id="tipClip">
          <rect id="tipClipRect" x="0" y="0" rx="12" ry="12" width="420" height="120"></rect>
        </clipPath>
      </defs>

      <g id="tooltip" visibility="hidden">
        <rect id="tipRect" class="tip-box" x="0" y="0" rx="12" ry="12" width="420" height="120"></rect>
        <g clip-path="url(#tipClip)">
          <text id="tipTitle" class="tip-title" x="16" y="12" dominant-baseline="hanging"></text>
          <text id="tipText" class="tip-text" x="16" y="44" dominant-baseline="hanging"></text>
        </g>
      </g>
    </svg>
  </div>

  <aside id="side">
    <div class="row"><b id="count">노드: ...</b></div>

    <div class="row">
      <button class="btn" id="btnFit">화면에 맞춤</button>
      <button class="btn" id="btnCloseTip">말풍선 닫기</button>
    </div>

    <hr/>

    <div><b>필터</b></div>
    <label><input type="checkbox" id="f-r" checked>빨강</label>
    <label><input type="checkbox" id="f-b" checked>파랑</label>
    <label><input type="checkbox" id="f-g" checked>초록</label>

    <hr/>
    <div class="muted">
      • 노드 탭/클릭하면 제목/설명이 말풍선으로 떠.<br/>
      • PC: 마우스 휠 확대/축소, 드래그 이동 가능.<br/>
      • 모바일: 두 손가락으로 확대/이동 가능.<br/>
      • 이미지/노드가 안 맞아 보이면 “화면에 맞춤” 눌러.
    </div>
  </aside>
</div>

<script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>

<script>
  const IMG_W = 2996, IMG_H = 2832;
  const DEFAULT_PIN_R = 18;

  // 툴팁 크기/타이포 (원하면 여기 숫자만 조절하면 됨)
  const TIP = {
    w: 420,
    padX: 16,
    titleY: 12,
    textY: 44,
    // 줄바꿈 기준(글자수). 폰트 크게 했으니 더 적게.
    wrapLen: 28,
    maxLines: 7,
    // 높이 계산: 기본 + 줄수*라인높이
    baseH: 56,
    lineH: 22,
    // 노드에서 떨어진 거리
    offsetX: 26,
    offsetY: -18
  };

  const eventsHandler = {
    haltEventListeners: ['touchstart','touchend','touchmove','touchleave','touchcancel'],
    init: function(options) {
      const instance = options.instance;
      let initialScale = 1;
      let pannedX = 0, pannedY = 0;

      this.hammer = new Hammer(options.svgElement, { inputClass: Hammer.TouchInput });
      this.hammer.get('pinch').set({ enable: true });
      const dbl = this.hammer.get('doubletap');
      if (dbl) dbl.set({ enable: false });

      this.hammer.on('panstart panmove', function(ev) {
        if (ev.type === 'panstart') { pannedX = 0; pannedY = 0; }
        instance.panBy({ x: ev.deltaX - pannedX, y: ev.deltaY - pannedY });
        pannedX = ev.deltaX; pannedY = ev.deltaY;
      });

      this.hammer.on('pinchstart pinchmove', function(ev) {
        if (ev.type === 'pinchstart') initialScale = instance.getZoom();
        instance.zoomAtPoint(initialScale * ev.scale, { x: ev.center.x, y: ev.center.y });
      });

      options.svgElement.addEventListener('touchmove', function(e){ e.preventDefault(); }, { passive:false });
    },
    destroy: function(){ this.hammer && this.hammer.destroy(); }
  };

  const panZoom = svgPanZoom('#svg', {
    zoomEnabled: true,
    panEnabled: true,
    controlIconsEnabled: false,
    fit: true,
    center: true,
    minZoom: 0.15,
    maxZoom: 20,
    dblClickZoomEnabled: false,
    preventMouseEventsDefault: false,
    customEventsHandler: eventsHandler
  });

  function forceFitCenter() {
    try { panZoom.resize(); panZoom.fit(); panZoom.center(); } catch(e) {}
  }
  window.addEventListener('load', () => { forceFitCenter(); setTimeout(forceFitCenter, 150); setTimeout(forceFitCenter, 450); });
  window.addEventListener('resize', () => { forceFitCenter(); });

  async function loadNodes() {
    const res = await fetch('nodes.json', { cache: 'no-store' });
    const data = await res.json();
    if (Array.isArray(data)) return data;
    if (data && Array.isArray(data.nodes)) return data.nodes;
    return [];
  }

  const svg = document.getElementById('svg');
  const pinsEl = document.getElementById('pins');

  const tip = document.getElementById('tooltip');
  const tipRect = document.getElementById('tipRect');
  const tipClipRect = document.getElementById('tipClipRect');
  const tipTitle = document.getElementById('tipTitle');
  const tipText = document.getElementById('tipText');

  function setTipVisible(v){ tip.setAttribute('visibility', v ? 'visible' : 'hidden'); }
  function clearText(el){ while (el.firstChild) el.removeChild(el.firstChild); }

  function wrapText(str, maxLen) {
    if (!str) return [''];
    const rawLines = String(str).split('\n');
    const out = [];
    for (const l of rawLines) {
      let s = l.trim();
      if (!s) { out.push(''); continue; }
      while (s.length > maxLen) {
        out.push(s.slice(0, maxLen));
        s = s.slice(maxLen);
      }
      out.push(s);
    }
    return out;
  }

  function setMultilineText(textEl, x, y, lines) {
    textEl.setAttribute('x', x);
    textEl.setAttribute('y', y);
    clearText(textEl);

    lines.forEach((ln, i) => {
      const tspan = document.createElementNS('http://www.w3.org/2000/svg','tspan');
      tspan.setAttribute('x', x);
      tspan.setAttribute('dy', i === 0 ? '0' : '1.25em');
      tspan.textContent = ln;
      textEl.appendChild(tspan);
    });
  }

  function showTooltipAt(node) {
    const title = node.name || node.title || '(제목 없음)';
    const desc = node.desc || node.detail || node.description || '';

    const lines = wrapText(desc, TIP.wrapLen).slice(0, TIP.maxLines);
    const lineCount = Math.max(1, lines.length);

    const w = TIP.w;
    const h = TIP.baseH + (lineCount * TIP.lineH);

    let x = node.x + TIP.offsetX;
    let y = node.y + TIP.offsetY;

    if (x + w > IMG_W) x = node.x - w - TIP.offsetX;
    if (x < 10) x = 10;
    if (y + h > IMG_H) y = IMG_H - h - 10;
    if (y < 10) y = 10;

    tipRect.setAttribute('x', x);
    tipRect.setAttribute('y', y);
    tipRect.setAttribute('width', w);
    tipRect.setAttribute('height', h);

    tipClipRect.setAttribute('x', x);
    tipClipRect.setAttribute('y', y);
    tipClipRect.setAttribute('width', w);
    tipClipRect.setAttribute('height', h);

    clearText(tipTitle);
    tipTitle.textContent = title;
    tipTitle.setAttribute('x', x + TIP.padX);
    tipTitle.setAttribute('y', y + TIP.titleY);

    setMultilineText(tipText, x + TIP.padX, y + TIP.textY, lines);
    setTipVisible(true);
  }

  function hideTooltip(){ setTipVisible(false); }

  function makeNodeEl(node){
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.classList.add('pin');
    g.dataset.c = node.c || node.color || 'r';

    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
    circle.setAttribute('cx', node.x);
    circle.setAttribute('cy', node.y);
    circle.setAttribute('r', node.radius || DEFAULT_PIN_R);
    circle.classList.add(g.dataset.c);

    const t = (node.n ?? node.num ?? '') || '';
    if (t !== '') {
      const text = document.createElementNS('http://www.w3.org/2000/svg','text');
      text.setAttribute('x', node.x);
      text.setAttribute('y', node.y + 6);
      text.setAttribute('text-anchor','middle');
      text.classList.add('num');
      text.textContent = t;
      g.appendChild(text);
    }

    g.insertBefore(circle, g.firstChild);

    g.addEventListener('click', (ev) => {
      ev.stopPropagation();
      showTooltipAt(node);
    }, { passive: true });

    g.addEventListener('touchend', (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      showTooltipAt(node);
    }, { passive: false });

    return g;
  }

  function applyFilter(){
    const fr = document.getElementById('f-r').checked;
    const fb = document.getElementById('f-b').checked;
    const fg = document.getElementById('f-g').checked;
    [...pinsEl.children].forEach(g=>{
      const c = g.dataset.c;
      const show = (c === 'r') ? fr : (c === 'b') ? fb : fg;
      g.style.display = show ? '' : 'none';
    });
  }

  svg.addEventListener('click', () => hideTooltip(), { passive:true });
  svg.addEventListener('touchend', () => hideTooltip(), { passive:true });

  document.getElementById('btnFit').addEventListener('click', () => { hideTooltip(); forceFitCenter(); });
  document.getElementById('btnCloseTip').addEventListener('click', () => hideTooltip());
  ['f-r','f-b','f-g'].forEach(id => document.getElementById(id).addEventListener('change', applyFilter));

  (async function init(){
    let nodes = [];
    try{ nodes = await loadNodes(); }catch(e){ console.error(e); nodes = []; }
    document.getElementById('count').textContent = `노드: ${nodes.length}`;

    pinsEl.innerHTML = '';
    for (const n of nodes){
      if (typeof n.x !== 'number' || typeof n.y !== 'number') continue;
      pinsEl.appendChild(makeNodeEl(n));
    }
    applyFilter();
    forceFitCenter();
  })();
</script>
</body>
</html>
