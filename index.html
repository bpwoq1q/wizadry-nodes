<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Wizardry Nodes (Read-only)</title>
  <style>
    :root{
      --bg:#0f0f12; --panel:#0f0f12; --border:#262630; --text:#eee;
      --muted:rgba(255,255,255,.7);
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;}
    #wrap{display:flex; height:100vh; height:100dvh;}
    #viewer{flex:1; position:relative; overflow:hidden; min-width:0;}
    #side{
      width:320px; max-width:45vw;
      border-left:1px solid var(--border);
      background:var(--panel);
      box-sizing:border-box;
      padding:12px;
      overflow:auto;
    }
    #map{width:100%;height:100%;}
    .row{display:flex;align-items:center;gap:8px;margin:8px 0;}
    .hint{font-size:12px; color:var(--muted); line-height:1.35;}
    h3{margin:10px 0 6px; font-size:13px; font-weight:800; color:#cfcfe8;}
    hr{border:0;border-top:1px solid var(--border); margin:12px 0;}

    /* Responsive: 모바일에서는 사이드바를 아래로 */
    @media (max-width: 900px){
      #wrap{flex-direction:column;}
      #side{
        width:100%;
        max-width:none;
        border-left:none;
        border-top:1px solid var(--border);
        padding:10px 12px;
        max-height:40vh;
      }
      #viewer{height:60vh;}
    }

    /* Pins (SVG) */
    .pin{cursor:pointer}
    .r{fill:#d63a3a} .b{fill:#2f6bff} .g{fill:#20a56b}
    .num{fill:#fff;font-weight:900;font-size:14px;pointer-events:none}
    .ring{stroke:rgba(255,255,255,.9);stroke-width:2}

    /* Tooltip bubble */
    #tooltip{
      position:absolute;
      z-index:10;
      min-width:180px;
      max-width:min(320px, 80vw);
      background:rgba(20,20,26,.96);
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      padding:10px 12px;
      box-shadow:0 10px 30px rgba(0,0,0,.45);
      backdrop-filter: blur(6px);
      display:none;
    }
    #tooltip .t{font-weight:900; font-size:14px; margin-bottom:6px;}
    #tooltip .d{font-size:12px; color:rgba(255,255,255,.82); white-space:pre-wrap;}
    #tooltip .x{
      position:absolute; top:6px; right:8px;
      width:28px; height:28px; border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:#fff; cursor:pointer;
    }

    /* Small controls */
    .btn{
      display:inline-flex; align-items:center; justify-content:center;
      padding:6px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:#eee;
      cursor:pointer;
      font-size:12px;
      user-select:none;
    }
    .btn:active{transform:translateY(1px);}
    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:11px;opacity:.85;border:1px solid rgba(255,255,255,.14);padding:1px 6px;border-radius:8px;}
  </style>
</head>
<body>
<div id="wrap">
  <div id="viewer">
    <div id="map"></div>

    <div id="tooltip" role="dialog" aria-modal="false">
      <button class="x" id="ttClose" aria-label="닫기">✕</button>
      <div class="t" id="ttTitle"></div>
      <div class="d" id="ttDesc"></div>
    </div>
  </div>

  <aside id="side">
    <div class="row"><b id="counter">노드: 0</b></div>

    <div class="row">
      <button class="btn" id="btnFit">화면에 맞춤</button>
      <button class="btn" id="btnHideTip">말풍선 닫기</button>
    </div>

    <hr/>

    <h3>필터</h3>
    <div class="row"><input type="checkbox" id="f-r" checked> <label for="f-r">빨강</label></div>
    <div class="row"><input type="checkbox" id="f-b" checked> <label for="f-b">파랑</label></div>
    <div class="row"><input type="checkbox" id="f-g" checked> <label for="f-g">초록</label></div>

    <hr/>
    <div class="hint">
      • 노드 탭하면 제목/설명 말풍선이 떠.<br/>
      • PC에서 스크롤 줌 가능, 드래그로 이동 가능.<br/>
      • 모바일에서 두 손가락으로 확대/이동 가능.<br/>
      • 잘 안 맞으면 <span class="kbd">화면에 맞춤</span> 눌러.
    </div>
  </aside>
</div>

<script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>

<script>
(() => {
  const IMG_W = 2996;
  const IMG_H = 2832;
  const TREE_SRC = "tree.png";
  const NODES_SRC = "nodes.json";

  const mapEl = document.getElementById("map");
  const counterEl = document.getElementById("counter");

  const tooltip = document.getElementById("tooltip");
  const ttTitle = document.getElementById("ttTitle");
  const ttDesc  = document.getElementById("ttDesc");
  const btnFit  = document.getElementById("btnFit");
  const btnHideTip = document.getElementById("btnHideTip");

  const fR = document.getElementById("f-r");
  const fB = document.getElementById("f-b");
  const fG = document.getElementById("f-g");

  function esc(s){
    return (s ?? "").toString()
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#39;");
  }

  async function loadNodes(){
    try{
      const res = await fetch(NODES_SRC, {cache:"no-store"});
      const data = await res.json();
      if (Array.isArray(data)) return data;
      if (data && Array.isArray(data.nodes)) return data.nodes;
      return [];
    }catch(e){
      console.warn("nodes.json load failed:", e);
      return [];
    }
  }

  function getFilters(){
    return { r: fR.checked, b: fB.checked, g: fG.checked };
  }

  function hideTooltip(){
    tooltip.style.display = "none";
  }

  function showTooltipAt(x, y, title, desc){
    ttTitle.textContent = title || "";
    ttDesc.textContent  = desc  || "";
    tooltip.style.display = "block";

    // position relative to viewer
    const viewerRect = document.getElementById("viewer").getBoundingClientRect();
    const pad = 10;

    // default offset
    let left = x + 14;
    let top  = y + 14;

    // measure
    tooltip.style.left = "0px";
    tooltip.style.top  = "0px";
    const w = tooltip.offsetWidth;
    const h = tooltip.offsetHeight;

    // clamp within viewer
    if (left + w > viewerRect.width - pad) left = x - w - 14;
    if (top + h > viewerRect.height - pad) top = y - h - 14;
    left = Math.max(pad, Math.min(left, viewerRect.width - w - pad));
    top  = Math.max(pad, Math.min(top,  viewerRect.height - h - pad));

    tooltip.style.left = left + "px";
    tooltip.style.top  = top + "px";
  }

  function pointToViewerPx(svgEl, svgPoint){
    // svgPoint is in SVG user units; convert to screen px and then to viewer-relative px
    const pt = svgEl.createSVGPoint();
    pt.x = svgPoint.x; pt.y = svgPoint.y;
    const screen = pt.matrixTransform(svgEl.getScreenCTM());
    const viewerRect = document.getElementById("viewer").getBoundingClientRect();
    return { x: screen.x - viewerRect.left, y: screen.y - viewerRect.top };
  }

  function createSvg(){
    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    svg.id = "svg";
    svg.setAttribute("width", "100%");
    svg.setAttribute("height", "100%");
    svg.setAttribute("viewBox", `0 0 ${IMG_W} ${IMG_H}`);
    svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
    svg.style.touchAction = "none";

    const img = document.createElementNS(svgNS, "image");
    img.setAttribute("href", TREE_SRC);
    img.setAttribute("x", "0");
    img.setAttribute("y", "0");
    img.setAttribute("width", IMG_W);
    img.setAttribute("height", IMG_H);
    img.setAttribute("id", "bg");
    svg.appendChild(img);

    const pins = document.createElementNS(svgNS, "g");
    pins.setAttribute("id", "pins");
    svg.appendChild(pins);

    mapEl.innerHTML = "";
    mapEl.appendChild(svg);

    // Disable native dblclick zoom behavior
    svg.addEventListener("dblclick", (e) => { e.preventDefault(); e.stopPropagation(); }, {passive:false});

    // Click outside nodes closes tooltip
    svg.addEventListener("pointerdown", (e) => {
      // if clicking background or empty area, close tooltip
      if (!e.target.closest || !e.target.closest(".pin")) hideTooltip();
    });

    return { svg, pins, img };
  }

  function renderPins(svg, pins, nodes){
    pins.innerHTML = "";
    const svgNS = "http://www.w3.org/2000/svg";
    const f = getFilters();

    for(const node of nodes){
      const id = node.id ?? "";
      const c  = (node.c ?? node.color ?? "r").toString().toLowerCase();
      const n  = (node.n ?? "").toString();
      const title = node.name ?? node.title ?? "";
      const desc  = node.desc ?? node.description ?? node.effect ?? "";

      if (!f[c]) continue;

      const g = document.createElementNS(svgNS, "g");
      g.classList.add("pin");
      g.dataset.id = id;
      g.dataset.c = c;

      const circle = document.createElementNS(svgNS, "circle");
      circle.setAttribute("cx", node.x);
      circle.setAttribute("cy", node.y);
      circle.setAttribute("r", node.r ?? 16);
      circle.classList.add(c);
      circle.classList.add("ring");

      const text = document.createElementNS(svgNS, "text");
      text.setAttribute("x", node.x);
      text.setAttribute("y", Number(node.y) + 5);
      text.setAttribute("text-anchor", "middle");
      text.classList.add("num");
      text.textContent = n;

      g.appendChild(circle);
      g.appendChild(text);

      g.addEventListener("click", (e) => {
        e.stopPropagation();
        // Use node center point -> viewer px
        const p = pointToViewerPx(svg, {x: Number(node.x), y: Number(node.y)});
        showTooltipAt(p.x, p.y, title, desc);
      });

      pins.appendChild(g);
    }
  }

  function initPanZoom(svg){
    const panZoom = svgPanZoom(svg, {
      zoomEnabled: true,
      controlIconsEnabled: false,
      fit: true,
      center: true,
      minZoom: 0.2,
      maxZoom: 20,
      dblClickZoomEnabled: false
    });

    function refit(){
      try{
        panZoom.resize();
        panZoom.fit();
        panZoom.center();
      }catch(_){}
    }

    // Buttons
    btnFit.addEventListener("click", () => {
      hideTooltip();
      refit();
    });
    btnHideTip.addEventListener("click", hideTooltip);
    document.getElementById("ttClose").addEventListener("click", hideTooltip);

    // Refit on orientation / resize (mobile)
    let t = null;
    window.addEventListener("resize", () => {
      clearTimeout(t);
      t = setTimeout(refit, 200);
    });
    window.addEventListener("orientationchange", () => setTimeout(refit, 250));

    // Initial refit twice (mobile sometimes needs a second pass)
    setTimeout(refit, 50);
    setTimeout(refit, 300);

    // Hide tooltip while panning/zooming to avoid weird position
    svg.addEventListener("wheel", hideTooltip, {passive:true});
    svg.addEventListener("pointermove", () => {
      // if user is dragging, close tooltip
      // (simple heuristic: not perfect but good enough)
    });

    return panZoom;
  }

  (async () => {
    const nodes = await loadNodes();
    counterEl.textContent = `노드: ${nodes.length}`;

    const { svg, pins, img } = createSvg();

    // Re-render when filters change
    const rerender = () => {
      hideTooltip();
      renderPins(svg, pins, nodes);
    };
    [fR, fB, fG].forEach(el => el.addEventListener("change", rerender));

    // Wait until bg image is available enough; then init panzoom and render
    // (Still render immediately so user sees something)
    rerender();
    initPanZoom(svg);

    // If image fails to load, tell user in console
    img.addEventListener("error", () => console.warn("Failed to load tree image:", TREE_SRC));
  })();
})();
</script>
</body>
</html>
